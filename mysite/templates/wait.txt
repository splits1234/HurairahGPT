# Copyright (c) 2025 Hurairah
# All Rights Reserved. Proprietary Software.
# Legal matters handled by parent/guardian until age 18.
# Governed by Pakistan law (Rawalpindi jurisdiction).
import re
import uuid
import traceback
from flask import Flask, render_template, request, redirect, session, url_for, jsonify, Response, stream_with_context, send_file, abort
from openai import OpenAI
import json
import os
import time
from datetime import datetime, timedelta
import requests
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from pathlib import Path
import io

app = Flask(__name__)
app.secret_key = "supersecretkey"

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
USERS_FILE = os.path.join(BASE_DIR, "users.json")
RATE_FILE = os.path.join(BASE_DIR, "rate_limits.json")

if not os.path.exists(USERS_FILE):
    with open(USERS_FILE, "w") as f:
        json.dump({}, f)

# persistent rate file
if not os.path.exists(RATE_FILE):
    with open(RATE_FILE, "w") as f:
        json.dump({}, f)

MOBILE_UA_RE = re.compile(r"android|iphone|ipad|ipod|blackberry|iemobile|windows phone|opera mini|mobile", re.I)

client = OpenAI(
    api_key="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",
    base_url="https://openrouter.ai/api/v1"
)

MODEL = "deepseek/deepseek-chat"
PERSONALITIES = {
    "default": "You are a helpful AI assistant.",
    "funny": "You are sarcastic, witty, and always crack jokes.",
    "islamic": "You answer with Islamic knowledge, Quran, and Hadith (avoid opinions).",
    "coder": "You are a senior programmer. Answer with code first, minimal talk."
}

ADMIN_EMAIL = "hurairah@gmail.com"  # change as needed

# Limits
DAILY_LIMIT = 2000
BURST_LIMIT = 30  # messages per minute
BURST_WINDOW = 60

try:
    import reportlab
    from reportlab.lib.pagesizes import letter
    from reportlab.pdfgen import canvas
    HAVE_REPORTLAB = True
except Exception:
    HAVE_REPORTLAB = False

try:
    from gtts import gTTS
    HAVE_GTTS = True
except Exception:
    HAVE_GTTS = False

def load_json(path, default):
    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except:
        return default

def save_json(path, data):
    with open(path, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2, ensure_ascii=False)

def load_users():
    return load_json(USERS_FILE, {})

def save_users(users):
    save_json(USERS_FILE, users)

def load_rate_limits():
    return load_json(RATE_FILE, {})

def save_rate_limits(r):
    save_json(RATE_FILE, r)

def send_email(to_email, subject, body):
    sender_email = "hurairahgpt.devteam@gmail.com"
    sender_password = "zexs xnud wwoq rlxe"

    msg = MIMEMultipart()
    msg["From"] = sender_email
    msg["To"] = to_email
    msg["Subject"] = subject
    msg.attach(MIMEText(body, "plain"))

    try:
        server = smtplib.SMTP("smtp.gmail.com", 587)
        server.starttls()
        server.login(sender_email, sender_password)
        server.send_message(msg)
        server.quit()
        return True, "Email sent successfully."
    except Exception as e:
        return False, str(e)

def find_credentials(email_to_find):
    path = Path(BASE_DIR) / "credentials.txt"
    path.touch(exist_ok=True)
    text = path.read_text(encoding="utf-8", errors="ignore")
    for line in text.splitlines():
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        for sep in [":", ",", " ", "\t"]:
            if sep in line:
                parts = [p.strip() for p in line.split(sep, 1)]
                if len(parts) >= 2 and parts[0].lower() == email_to_find.lower():
                    return parts[1]
    return None

def retry_request(func, retries=3, delay=1, fallback="Unavailable"):
    last_error = None
    for attempt in range(retries):
        try:
            return func()
        except Exception as e:
            last_error = e
            if attempt < retries - 1:
                time.sleep(delay)
            else:
                print(f"Error after {retries} attempts: {type(e).__name__}: {str(e)}")
                print(f"Traceback: {traceback.format_exc()}")
    return fallback

def get_islamic_date():
    def _call():
        res = requests.get("http://api.aladhan.com/v1/gToH",
                           params={"date": datetime.now().strftime("%d-%m-%Y")},
                           timeout=5)
        hijri = res.json()["data"]["hijri"]["date"]
        return f"Islamic date: {hijri}"
    return retry_request(_call, fallback="Islamic date unavailable.")

def excontext():
    return f"your in an app called hurairahgpt. website is talktohurairah.com your developed by hurairah"

def get_news_headline():
    def _call():
        res = requests.get("https://newsapi.org/v2/top-headlines",
                           params={"country": "pk",
                                   "apiKey": "418ef79bb38a4535b08a51a4b48a8c4b"},
                           timeout=5)
        data = res.json()
        if data.get("status") == "ok" and data.get("totalResults", 0) > 0:
            return f"Top news: {data['articles'][0]['title']}"
        return "No news articles found."
    return retry_request(_call, fallback="News unavailable.")

def migrate_user_to_sessions(user_data):
    if "sessions" in user_data:
        return user_data
    session_id = str(uuid.uuid4())
    old_history = user_data.get("history", [])
    user_data["sessions"] = {
        session_id: {
            "name": "Chat 1",
            "history": old_history,
            "created": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }
    }
    user_data["active_session"] = session_id
    if "history" in user_data:
        del user_data["history"]
    return user_data

def get_user_data_with_sessions(gmail):
    users = load_users()
    user_data = users.get(gmail, {
        "sessions": {},
        "active_session": None,
        "theme": "dark",
        "personality": "default",
        "banned": False,
        "2fa": {}
    })
    user_data = migrate_user_to_sessions(user_data)
    if not user_data.get("active_session") or user_data["active_session"] not in user_data.get("sessions", {}):
        if not user_data.get("sessions"):
            session_id = str(uuid.uuid4())
            user_data["sessions"] = {
                session_id: {
                    "name": "Chat 1",
                    "history": [],
                    "created": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                }
            }
            user_data["active_session"] = session_id
        else:
            user_data["active_session"] = list(user_data["sessions"].keys())[0]
    users[gmail] = user_data
    save_users(users)
    return user_data

def get_active_session_history(user_data):
    active_id = user_data.get("active_session")
    if not active_id:
        return []
    sessions = user_data.get("sessions", {})
    active_session = sessions.get(active_id, {})
    return active_session.get("history", [])

# Rate limiting helpers
def check_rate_limit(gmail):
    r = load_rate_limits()
    now = int(time.time())
    ip = request.remote_addr or "unknown"
    ip_key = f"ip:{ip}"
    user_key = f"user:{gmail}"

    def incr(key):
        rec = r.get(key, {"count": 0, "window_start": now})
        # reset per-minute window for burst
        if now - rec.get("window_start", now) > BURST_WINDOW:
            rec = {"count": 0, "window_start": now}
        rec["count"] = rec.get("count", 0) + 1
        r[key] = rec
        return rec["count"]

    # per-minute burst checks
    ip_count = incr(ip_key)
    user_count = incr(user_key + ":burst")

    # daily count
    daily = r.get(f"{user_key}:daily", {"count": 0, "start_day": datetime.utcnow().strftime("%Y-%m-%d")})
    if daily.get("start_day") != datetime.utcnow().strftime("%Y-%m-%d"):
        daily = {"count": 0, "start_day": datetime.utcnow().strftime("%Y-%m-%d")}
    daily["count"] += 1
    r[f"{user_key}:daily"] = daily

    save_rate_limits(r)

    if ip_count > BURST_LIMIT * 4:
        return False, "IP rate limit exceeded"
    if user_count > BURST_LIMIT:
        return False, "Too many requests, slow down"
    if daily["count"] > DAILY_LIMIT:
        return False, "Daily message limit exceeded"
    return True, None

# Plugin example: weather
def plugin_weather(query):
    try:
        city = query.strip()
        if not city:
            return "Usage: /weather CITY"
        res = requests.get("http://api.openweathermap.org/data/2.5/weather",
                           params={"q": city, "appid": "YOUR_OPENWEATHER_KEY", "units": "metric"},
                           timeout=6)
        if res.status_code != 200:
            return "Weather plugin: city not found or API error."
        data = res.json()
        s = f"Weather in {data['name']}: {data['weather'][0]['description']}. Temp: {data['main']['temp']}°C. Humidity: {data['main']['humidity']}%."
        return s
    except Exception:
        return "Weather plugin failed."

def create_session_title(gmail, session_id):
    users = load_users()
    user_data = users.get(gmail)
    if not user_data:
        return
    session = user_data["sessions"].get(session_id)
    if not session:
        return
    history = session.get("history", [])
    snippet = ""
    if history:
        for m in reversed(history[-10:]):
            if m.get("sender") == "user":
                snippet = m.get("content")
                break
    if not snippet:
        return
    messages = [{"role":"system","content":"Provide a concise 3-5 word title for a chat based on the user's last message. Output only the title."},
                {"role":"user","content": snippet}]
    try:
        resp = client.chat.completions.create(model=MODEL, messages=messages, timeout=10)
        title = resp.choices[0].message.content.strip()
        # sanitize
        title = title.split("\n")[0][:60]
        user_data["sessions"][session_id]["name"] = title or user_data["sessions"][session_id]["name"]
        save_users(users)
    except Exception:
        pass

def summarize_session_if_needed(gmail, session_id):
    users = load_users()
    ud = users.get(gmail)
    if not ud:
        return
    s = ud["sessions"].get(session_id)
    if not s:
        return
    hist = s.get("history", [])
    if len(hist) >= 50 and not ud.get("memory_summary"):
        # create a short summary and store
        try:
            messages = [{"role":"system","content":"Summarize the following chat into a concise paragraph, focus on user preferences and important facts."},
                        {"role":"user","content":"\n\n".join([f"{h['sender']}: {h['content']}" for h in hist[-200:]])}]
            resp = client.chat.completions.create(model=MODEL, messages=messages, timeout=20)
            summary = resp.choices[0].message.content.strip()
            ud["memory_summary"] = summary
            users[gmail] = ud
            save_users(users)
        except Exception:
            pass

@app.route("/")
def root():
    if "gmail" not in session:
        return redirect(url_for("login"))
    ua = request.headers.get("User-Agent", "")
    is_mobile = bool(MOBILE_UA_RE.search(ua))
    if request.args.get("mobile") in ("1", "true", "yes"):
        is_mobile = True
    if request.args.get("desktop") in ("1", "true", "yes"):
        is_mobile = False
    user_data = get_user_data_with_sessions(session["gmail"])
    history = get_active_session_history(user_data)
    sessions_list = user_data.get("sessions", {})
    active_session_id = user_data.get("active_session")
    if is_mobile:
        return render_template("moindex.html",
                               gmail=session["gmail"],
                               history=history,
                               theme=user_data["theme"],
                               sessions=sessions_list,
                               active_session=active_session_id)
    return render_template("index.html",
                           gmail=session["gmail"],
                           history=history,
                           theme=user_data["theme"],
                           sessions=sessions_list,
                           active_session=active_session_id)

@app.route("/login", methods=["GET", "POST"])
def login():
    if request.method == "POST":
        gmail = request.form.get("gmail", "").strip()
        password = request.form.get("password", "").strip()
        if not gmail or not password:
            return render_template("login.html", error="Please fill out all fields.")
        # guest
        if gmail.lower() == "guest@gmail.com" and password == "guest":
            session["gmail"] = "guest@gmail.com"
            users = load_users()
            if "guest@gmail.com" not in users:
                session_id = str(uuid.uuid4())
                users["guest@gmail.com"] = {
                    "sessions": {
                        session_id: {
                            "name": "Chat 1",
                            "history": [],
                            "created": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                        }
                    },
                    "active_session": session_id,
                    "theme": "dark",
                    "personality": "default",
                    "banned": False
                }
                save_users(users)
            return redirect(url_for("root"))
        # credentials
        stored_pw = find_credentials(gmail)
        if not stored_pw:
            return render_template("login.html", error="Account not found. Please sign up first.")
        if stored_pw != password:
            return render_template("login.html", error="Incorrect password.")
        users = load_users()
        if gmail in users and users[gmail].get("banned"):
            return render_template("login.html", error="This account is banned.")
        # Start 2FA for non-guest
        # generate code and send, store temporarily
        code = str(uuid.uuid4().int)[:6]
        users[gmail] = users.get(gmail, {})
        users[gmail].setdefault("2fa", {})
        users[gmail]["2fa"] = {"code": code, "expires": (datetime.utcnow() + timedelta(minutes=10)).strftime("%Y-%m-%dT%H:%M:%SZ")}
        save_users(users)
        ok, msg = send_email(gmail, "Your HurairahGPT login code", f"Your login code is: {code}")
        if not ok:
            # if email fails, fallback to login (developer choice)
            session["gmail"] = gmail
            if gmail not in users:
                session_id = str(uuid.uuid4())
                users[gmail] = {
                    "sessions": {session_id: {"name": "Chat 1", "history": [], "created": datetime.now().strftime("%Y-%m-%d %H:%M:%S")}},
                    "active_session": session_id,
                    "theme": "dark",
                    "personality": "default",
                    "banned": False
                }
                save_users(users)
            return redirect(url_for("root"))
        return render_template("verify_2fa.html", gmail=gmail, info="Enter the 6-digit code we emailed you.")
    return render_template("login.html")

@app.route("/start_2fa", methods=["POST"])
def start_2fa():
    gmail = request.form.get("gmail", "").strip()
    if not gmail:
        return jsonify({"error":"Missing email"}), 400
    users = load_users()
    code = str(uuid.uuid4().int)[:6]
    users.setdefault(gmail, {})
    users[gmail].setdefault("2fa", {})
    users[gmail]["2fa"] = {"code": code, "expires": (datetime.utcnow() + timedelta(minutes=10)).strftime("%Y-%m-%dT%H:%M:%SZ")}
    save_users(users)
    ok, msg = send_email(gmail, "HurairahGPT login code", f"Your login code is: {code}")
    return jsonify({"sent": ok, "msg": msg})

@app.route("/verify_2fa", methods=["POST"])
def verify_2fa():
    gmail = request.form.get("gmail", "").strip()
    code = request.form.get("code", "").strip()
    if not gmail or not code:
        return render_template("verify_2fa.html", gmail=gmail, error="Missing code.")
    users = load_users()
    ud = users.get(gmail, {})
    two = ud.get("2fa", {})
    expires = two.get("expires")
    if not two or two.get("code") != code:
        return render_template("verify_2fa.html", gmail=gmail, error="Invalid code.")
    if expires and datetime.utcnow() > datetime.fromisoformat(expires.replace("Z","+00:00")):
        return render_template("verify_2fa.html", gmail=gmail, error="Code expired.")
    session["gmail"] = gmail
    # create user if not exists
    if gmail not in users:
        session_id = str(uuid.uuid4())
        users[gmail] = {
            "sessions": {
                session_id: {
                    "name": "Chat 1",
                    "history": [],
                    "created": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                }
            },
            "active_session": session_id,
            "theme": "dark",
            "personality": "default",
            "banned": False
        }
    # clear 2fa
    if "2fa" in users[gmail]:
        del users[gmail]["2fa"]
    save_users(users)
    return redirect(url_for("root"))

@app.route("/signup", methods=["GET", "POST"])
def signup():
    if request.method == "POST":
        gmail = request.form.get("gmail", "").strip()
        password = request.form.get("password", "").strip()
        if not gmail or not password:
            return render_template("signup.html", error="Please fill out all fields.")
        credentials_path = os.path.join(BASE_DIR, "credentials.txt")
        os.makedirs(os.path.dirname(credentials_path), exist_ok=True)
        existing_pw = find_credentials(gmail)
        if existing_pw:
            return render_template("signup.html", error="Account already exists. Please log in.")
        with open(credentials_path, "a", encoding="utf-8") as f:
            f.write(f"{gmail}:{password}\n")
        users = load_users()
        session_id = str(uuid.uuid4())
        users[gmail] = {
            "sessions": {
                session_id: {
                    "name": "Chat 1",
                    "history": [],
                    "created": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                }
            },
            "active_session": session_id,
            "theme": "dark",
            "personality": "default",
            "banned": False
        }
        save_users(users)
        session["gmail"] = gmail
        return redirect(url_for("root"))
    return render_template("signup.html")

@app.route("/logout")
def logout():
    session.pop("gmail", None)
    return redirect(url_for("login"))

@app.route("/chat", methods=["POST"])
def chat():
    if "gmail" not in session:
        return jsonify({"error": "Unauthorized"}), 401
    gmail = session["gmail"]
    users = load_users()
    if gmail in users and users[gmail].get("banned"):
        return jsonify({"error": "Account banned."}), 403
    ok, reason = check_rate_limit(gmail)
    if not ok:
        return jsonify({"error": reason}), 429
    user_message = request.json.get("message", "")
    if not user_message:
        return jsonify({"error": "No message provided"}), 400
    incognito = bool(request.json.get("incognito", False))
    stream = request.json.get("stream", False)
    user_data = get_user_data_with_sessions(gmail)
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    active_session_id = user_data.get("active_session")
    if not active_session_id or active_session_id not in user_data.get("sessions", {}):
        return jsonify({"error": "No active session"}), 400
    active_session = user_data["sessions"][active_session_id]
    history = active_session.get("history", [])
    if user_message == "__CLEAR__":
        active_session["history"] = []
        users[gmail] = user_data
        save_users(users)
        return jsonify({"response": "Chat history cleared."})
    # plugin: weather
    if user_message.strip().startswith("/weather"):
        arg = user_message.strip()[len("/weather"):].strip()
        plugin_resp = plugin_weather(arg)
        if not incognito:
            history.append({"content": user_message, "sender": "user", "time": timestamp})
            history.append({"content": plugin_resp, "sender": "bot", "time": timestamp})
            active_session["history"] = history[-400:]
            users[gmail] = user_data
            save_users(users)
        return jsonify({"response": plugin_resp})
    user_personality = user_data.get("personality", "default")
    system_content = PERSONALITIES.get(user_personality, PERSONALITIES["default"]) + "\n\n" + "\n".join([
        f"Today is {datetime.now().strftime('%A, %B %d, %Y')}.",
        get_islamic_date(),
        get_news_headline(),
        excontext()
    ])
    messages = [{"role": "system", "content": system_content}]
    for entry in history:
        role = "user" if entry["sender"] == "user" else "assistant"
        messages.append({"role": role, "content": entry["content"]})
    messages.append({"role": "user", "content": user_message})
    # Save user message unless incognito
    if not incognito:
        history.append({"content": user_message, "sender": "user", "time": timestamp})
    # streaming
    if stream:
        def generate():
            full_response = ""
            try:
                stream_response = client.chat.completions.create(
                    model=MODEL,
                    messages=messages,
                    stream=True,
                    timeout=60
                )
                for chunk in stream_response:
                    if chunk.choices and len(chunk.choices) > 0:
                        delta = chunk.choices[0].delta
                        if hasattr(delta, 'content') and delta.content:
                            content = delta.content
                            full_response += content
                            yield f"data: {json.dumps({'chunk': content, 'done': False})}\n\n"
                yield f"data: {json.dumps({'chunk': '', 'done': True, 'full_response': full_response})}\n\n"
                if not incognito:
                    history.append({"content": full_response, "sender": "bot", "time": timestamp})
                    active_session["history"] = history[-400:]
                    users[gmail] = user_data
                    save_users(users)
                    # auto title + summary asynchronously-ish (best effort)
                    try:
                        create_session_title(gmail, active_session_id)
                        summarize_session_if_needed(gmail, active_session_id)
                    except Exception:
                        pass
            except Exception as e:
                error_msg = f"AI service unavailable, please try again later."
                print(f"Streaming API Error: {type(e).__name__}: {str(e)}")
                yield f"data: {json.dumps({'chunk': '', 'done': True, 'error': error_msg})}\n\n"
                if not incognito:
                    history.append({"content": error_msg, "sender": "bot", "time": timestamp})
                    active_session["history"] = history
                    users[gmail] = user_data
                    save_users(users)
        return Response(stream_with_context(generate()), mimetype='text/event-stream')
    # non-streaming
    def call_ai():
        try:
            response = client.chat.completions.create(
                model=MODEL,
                messages=messages,
                timeout=30
            )
            if not response.choices or len(response.choices) == 0:
                raise Exception("No response choices returned from API")
            return response.choices[0].message.content
        except Exception as e:
            error_msg = f"API Error: {type(e).__name__}: {str(e)}"
            print(error_msg)
            print(f"Model: {MODEL}, Base URL: {client.base_url}")
            raise
    ai_reply = retry_request(call_ai, retries=2, delay=2, fallback="AI service unavailable, please try again later.")
    if ai_reply == "AI service unavailable, please try again later.":
        print("Failed to get AI response after retries.")
    if not incognito:
        history.append({"content": ai_reply, "sender": "bot", "time": timestamp})
        active_session["history"] = history[-400:]
        users[gmail] = user_data
        save_users(users)
        try:
            create_session_title(gmail, active_session_id)
            summarize_session_if_needed(gmail, active_session_id)
        except Exception:
            pass
    return jsonify({"response": ai_reply})

@app.route("/generate_image", methods=["POST"])
def generate_image():
    if "gmail" not in session:
        return jsonify({"error":"Unauthorized"}), 401
    prompt = request.json.get("prompt","").strip()
    size = request.json.get("size","1024x1024")
    if not prompt:
        return jsonify({"error":"No prompt provided"}), 400
    try:
        # Try the client.images.generate path (OpenRouter-compatible clients may vary)
        resp = None
        try:
            resp = client.images.generate(prompt=prompt, size=size)
            # best-effort: extract url or base64
            if isinstance(resp, dict) and resp.get("data") and len(resp["data"])>0:
                return jsonify({"ok": True, "result": resp["data"]})
        except Exception:
            pass
        # fallback using HTTP request to OpenRouter image endpoint (if supported)
        r = requests.post(f"{client.base_url}/images/generations",
                          headers={"Authorization": f"Bearer {client.api_key}"},
                          json={"prompt": prompt, "size": size}, timeout=60)
        if r.status_code == 200:
            return jsonify({"ok": True, "result": r.json()})
        return jsonify({"error":"Image generation failed", "status": r.status_code, "body": r.text}), 500
    except Exception as e:
        print("Image generation error:", type(e).__name__, str(e))
        return jsonify({"error":"Image generation error"}), 500

@app.route("/tts", methods=["POST"])
def tts():
    if "gmail" not in session:
        return jsonify({"error":"Unauthorized"}), 401
    text = request.json.get("text","").strip()
    if not text:
        return jsonify({"error":"No text provided"}), 400
    if not HAVE_GTTS:
        return jsonify({"error":"TTS not available on server (install gtts)."}), 501
    try:
        t = gTTS(text=text, lang="en")
        buf = io.BytesIO()
        t.write_to_fp(buf)
        buf.seek(0)
        return send_file(buf, mimetype="audio/mpeg", as_attachment=True, download_name="tts.mp3")
    except Exception as e:
        print("TTS error:", type(e).__name__, str(e))
        return jsonify({"error":"TTS failed"}), 500

@app.route("/search", methods=["GET"])
def search_messages():
    if "gmail" not in session:
        return redirect(url_for("login"))
    q = request.args.get("q","").strip()
    if not q:
        return jsonify({"results": []})
    user_data = get_user_data_with_sessions(session["gmail"])
    active_session_id = user_data.get("active_session")
    hist = user_data["sessions"].get(active_session_id, {}).get("history", [])
    results = []
    for idx, m in enumerate(hist):
        if q.lower() in m.get("content","").lower():
            results.append({"index": idx, "sender": m.get("sender"), "content": m.get("content"), "time": m.get("time")})
    return jsonify({"results": results})

@app.route("/export/session/<session_id>", methods=["GET"])
def export_session(session_id):
    if "gmail" not in session:
        return redirect(url_for("login"))
    fmt = request.args.get("format","txt").lower()
    users = load_users()
    gmail = session["gmail"]
    user_data = users.get(gmail, {})
    ses = user_data.get("sessions", {}).get(session_id)
    if not ses:
        return jsonify({"error":"Session not found"}), 404
    hist = ses.get("history", [])
    if fmt == "json":
        return jsonify({"session": ses})
    if fmt == "txt":
        txt = "\n\n".join([f"[{m['time']}] {m['sender'].upper()}: {m['content']}" for m in hist])
        return Response(txt, mimetype="text/plain", headers={"Content-Disposition": f"attachment; filename=session-{session_id}.txt"})
    if fmt == "pdf":
        if not HAVE_REPORTLAB:
            return jsonify({"error":"PDF export requires reportlab. Install reportlab or use format=json/txt"}), 501
        buf = io.BytesIO()
        c = canvas.Canvas(buf, pagesize=letter)
        w, h = letter
        y = h - 40
        c.setFont("Helvetica", 10)
        c.drawString(40, y, f"Session: {ses.get('name','chat')}")
        y -= 20
        for m in hist:
            for line in (f"[{m['time']}] {m['sender'].upper()}: {m['content']}").splitlines():
                if y < 60:
                    c.showPage()
                    y = h - 40
                    c.setFont("Helvetica", 10)
                c.drawString(40, y, line[:200])
                y -= 14
        c.save()
        buf.seek(0)
        return send_file(buf, mimetype="application/pdf", as_attachment=True, download_name=f"session-{session_id}.pdf")
    return jsonify({"error":"Unknown format"}), 400

@app.route("/admin", methods=["GET","POST"])
def admin_dashboard():
    if "gmail" not in session or session["gmail"] != ADMIN_EMAIL:
        abort(403)
    users = load_users()
    if request.method == "POST":
        action = request.form.get("action")
        target = request.form.get("target")
        if action == "ban" and target in users:
            users[target]["banned"] = True
            save_users(users)
        if action == "unban" and target in users:
            users[target]["banned"] = False
            save_users(users)
        if action == "delete" and target in users:
            del users[target]
            save_users(users)
    # basic stats
    stats = {"total_users": len(users), "by_theme": {}, "total_sessions": 0}
    for k, v in users.items():
        t = v.get("theme","dark")
        stats["by_theme"][t] = stats["by_theme"].get(t,0)+1
        stats["total_sessions"] += len(v.get("sessions",{}))
    return render_template("admin.html", users=users, stats=stats, admin=ADMIN_EMAIL)

@app.route("/sessions/create", methods=["POST"])
def create_session():
    if "gmail" not in session:
        return jsonify({"error": "Unauthorized"}), 401
    users = load_users()
    user_data = get_user_data_with_sessions(session["gmail"])
    session_id = str(uuid.uuid4())
    session_name = request.json.get("name", "").strip() or f"Chat {len(user_data.get('sessions', {})) + 1}"
    user_data.setdefault("sessions", {})
    user_data["sessions"][session_id] = {
        "name": session_name,
        "history": [],
        "created": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    }
    user_data["active_session"] = session_id
    users[session["gmail"]] = user_data
    save_users(users)
    return jsonify({"success": True, "session_id": session_id, "sessions": user_data["sessions"]})

@app.route("/sessions/switch", methods=["POST"])
def switch_session():
    if "gmail" not in session:
        return jsonify({"error": "Unauthorized"}), 401
    session_id = request.json.get("session_id")
    if not session_id:
        return jsonify({"error": "No session_id provided"}), 400
    users = load_users()
    user_data = get_user_data_with_sessions(session["gmail"])
    if session_id not in user_data.get("sessions", {}):
        return jsonify({"error": "Session not found"}), 404
    user_data["active_session"] = session_id
    users[session["gmail"]] = user_data
    save_users(users)
    active_session = user_data["sessions"][session_id]
    return jsonify({
        "success": True,
        "history": active_session.get("history", []),
        "sessions": user_data["sessions"]
    })

@app.route("/sessions/delete", methods=["POST"])
def delete_session():
    if "gmail" not in session:
        return jsonify({"error": "Unauthorized"}), 401
    session_id = request.json.get("session_id")
    if not session_id:
        return jsonify({"error": "No session_id provided"}), 400
    users = load_users()
    user_data = get_user_data_with_sessions(session["gmail"])
    if session_id not in user_data.get("sessions", {}):
        return jsonify({"error": "Session not found"}), 404
    sessions = user_data.get("sessions", {})
    if len(sessions) <= 1:
        return jsonify({"error": "Cannot delete the last session"}), 400
    del sessions[session_id]
    if user_data.get("active_session") == session_id:
        user_data["active_session"] = list(sessions.keys())[0]
    users[session["gmail"]] = user_data
    save_users(users)
    active_session = user_data["sessions"][user_data["active_session"]]
    return jsonify({
        "success": True,
        "history": active_session.get("history", []),
        "sessions": user_data["sessions"],
        "active_session": user_data["active_session"]
    })

@app.route("/sessions/rename", methods=["POST"])
def rename_session():
    if "gmail" not in session:
        return jsonify({"error": "Unauthorized"}), 401
    session_id = request.json.get("session_id")
    new_name = request.json.get("name", "").strip()
    if not session_id or not new_name:
        return jsonify({"error": "Missing session_id or name"}), 400
    users = load_users()
    user_data = get_user_data_with_sessions(session["gmail"])
    if session_id not in user_data.get("sessions", {}):
        return jsonify({"error": "Session not found"}), 404
    user_data["sessions"][session_id]["name"] = new_name
    users[session["gmail"]] = user_data
    save_users(users)
    return jsonify({"success": True, "sessions": user_data["sessions"]})

@app.route("/personality", methods=["POST"])
def update_personality():
    if "gmail" not in session:
        return jsonify({"error": "Unauthorized"}), 401
    personality = request.json.get("personality", "default")
    users = load_users()
    if session["gmail"] in users:
        users[session["gmail"]]["personality"] = personality
        save_users(users)
    return jsonify({"success": True})

@app.route("/theme", methods=["POST"])
def update_theme():
    if "gmail" not in session:
        return jsonify({"error": "Unauthorized"}), 401
    theme = request.json.get("theme")
    users = load_users()
    if session["gmail"] in users:
        users[session["gmail"]]["theme"] = theme
        save_users(users)
    return jsonify({"success": True})

@app.route("/moindex")
def moindex():
    if "gmail" not in session:
        return redirect(url_for("login"))
    user_data = get_user_data_with_sessions(session["gmail"])
    history = get_active_session_history(user_data)
    sessions_list = user_data.get("sessions", {})
    active_session_id = user_data.get("active_session")
    return render_template("moindex.html",
                           gmail=session["gmail"],
                           history=history,
                           theme=user_data["theme"],
                           sessions=sessions_list,
                           active_session=active_session_id)

@app.route("/forgot", methods=["GET"])
def forgot_get():
    return render_template("reset.html")

@app.route("/forgot", methods=["POST"])
def forgot_post():
    email = request.form.get("email", "").strip()
    if not email:
        return render_template("reset.html", error="Please enter your email.")
    users = load_users()
    password_found = None
    if email in users and users[email].get("password"):
        password_found = users[email]["password"]
    else:
        pw = find_credentials(email)
        if pw:
            password_found = pw
    if not password_found:
        return render_template("reset.html", sent=True)
    subject = "HurairahGPT — Your account credentials"
    body = f"Hello,\n\nYou requested your account credentials for HurairahGPT.\n\nEmail: {email}\nPassword: {password_found}\n\nIf you did not request this, ignore this email.\n\n— HurairahGPT Team"
    ok, msg = send_email(email, subject, body)
    if ok:
        return render_template("reset.html", sent=True)
    else:
        return render_template("reset.html", error="Failed to send email. " + msg)

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000, debug=True)
